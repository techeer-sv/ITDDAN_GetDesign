# 시스템 디자인 인터뷰: 티켓 설계

[System Design Interview: Design Ticketmaster w/ a Ex-Meta Staff Engineer](https://www.youtube.com/watch?v=fhdPyoO6aXI&list=PL5q3E8eRUieWtYLmRU3z94-vGRcwKr9tM&index=2&ab_channel=HelloInterview-SWEInterviewPreparation)

<img width="1633" alt="스크린샷 2025-06-21 오후 5 28 38" src="https://github.com/user-attachments/assets/9dca16e9-8b29-4c47-add4-1e58768e3dc3" />

<br/><br/>

## **1. Requirements: 요구 사항을 기록하기**

1. Functional Requirement 기능적 요구 사항
    - 면접에선 일반적으로 대중적인 시스템. 미리 경험이 있으면 좋음
    - 경험이 없으면 면접관에게 시스템의 기능이나 사용자 사용 방식 등에 대해 질문하기
    1. 티켓 예약
    2. 이벤트 보기, 좌석 선택
    3. 이벤트 검색

2. Non-functional Requirements 비기능적 요구사항 (품질)
    1. 일관성과 가용성의 균형을 맞추는 것이 중요하다
    2. 티켓 예약 시에는 일관성을, 검색 시에는 가용성을 우선시
        - 가용성: 중단없이 작동하도록 - 시스템이 24시간 내내 접속 가능하고 검색이 항상 잘 됨
        - 일관성: 모든 데이터가 정확하고 최신 상태를 유지하는지 - 한 티켓이 여러 사람에게 동시에 예약되지 않도록
        - CAP 정리: Consistency 일관성, Availability 가용성, Partition Tolerance 분할 내성 중 동시에 두 가지만 만족시킬 수 있음
            - 분할 내성: 일부 장애가 발생하더라도 시스템이 계속 작동할 수 있는 능력 - 서버 A, B 중 하나가 죽어도 나머지는 잘 작동하도록
    3. 인기있는 이벤트에서 사용자 급증할 때의 **확장성**
    4. 사이트 사용 형태와 쿼리 접근 패턴 이해 필요

3. Out of scope 설계에서 논외인 항목
    1. GDPR: 유럽 사용자 개인정보 보호법
    2. fault tolerance 장애 대응: 서버나 시스템이 일부 고장나도 정상적으로 작동하게 하는지
  
<br/><br/>

## **2. 핵심 엔티티 정의** core entities

1. Event: name
2. Venue 장소
3. Performer
4. Ticket
- 초기에 필드를 세세히 정하지 않아도 됨. 세부 필드는 설계 과정에서 자연스럽게 발전시키거나 필요할 때 명시하는 것이 효율적.

<br/><br/>

## **3. API**

- 사용자-facing API: 클라이언트가 시스템 기능을 사용하기 위해 호출하는 인터페이스

1. Get /event/:eventId → 이벤트/장소/공연자/티켓 []
2. Get /search?term&location&type&date → Partial<Event>[]
3. Post /booking/reserve
    - 예약은 보통 단일 엔드포인트가 아님 → 2단계 예약 흐름: 예약과 확인
        - 사용자는 좌석을 선택한 후 10분 동안 해당 티켓을 예약할 수 있는 시간이 주어짐
    - body: {티켓아이디}
        - 사용자 아이디는 보안 문제로 요청 본문에 포함되지 않는 것이 바람직
4. Post /booking/confirm
    - 바디에 {티켓아이디, paymentDetails(sripe)}

<br/><br/>

## **4. Hign-level Design 고수준 시스템 설계**

- 고수준 설계에서는 일반적으로 마이크로 서비스 아키텍처를 선택
    1. 마이크로 서비스 아키텍처: 하나의 큰 애플리케이션을 여러 개의 작고 독립적인 서비스들로 나누어 구축하는 방식

- 클라이언트 - API 게이트웨이 - (Event CRUD Service / Search / Booking):MSA - Datebase
    1. event crud service
        - 데이터베이스는 이벤트/장소/공연자/티켓 테이블 포함. 외래 키 관계 가짐
            - 포스트그래를 추천함. ACID 속성이 중요하기 때문.
                - 최근에는 nosql도 sql디비와 유사한 기능을 제공하는 경우가 많기 때문에 특정을 고집하기 보단 요구사항에 맞는 특성을 가진 디비 선택.
        - 서비스는 필요한 정보를 조합하여 클라이언트에 반환함
   
    2. Search 서비스
        - 초기 검색 서비스는 단순 SQL쿼리로 검색 → 성능적 한계
            - LIKE %term% 같은 와일드 카드 검색은 전체 테이블 스캔 유발로 느림
            - 면접에선 이러한 한계점을 인지하고 있으며 이후 심층 분석 단계에서 최적화할 계획임을 언급해야함.
   
    3. Booking - Stripe(온라인 결제 서비스)
        1. 예약 요청과 확정 요청 2단계 흐름
            1. 예약 요청이 들어오면 티켓 상태를 예약중으로 업데이트 하고 이 후 결제 요청을 처리하기 위해 stripe와 통신한다 (/confirm)
            2. 결제 성공 시 티켓의 상태를 예약 완료로 최종 업데이트. 실패시 다시 사용가능 상태로 돌아감.
        2. 예약 만료 처리 문제점
            <img width="1835" alt="스크린샷 2025-06-21 오후 5 54 47" src="https://github.com/user-attachments/assets/3b8ab89e-3ee3-4b34-900e-feb5d1e5d623" />
            1. 예약된 티켓이 10분이라는 만료 시간 내 확정되지 않으면 해당 티켓은 영구적으로 예약됨 상태가 되어 다른 사람이 구매 못함.
        3. 해결 방안
            1. 타임스탬프 기반 쿼리: reserved_timestamp 추가해서 티켓 조회 시 10분 이상 경과한 티켓 조회
                - 한계: 디비 모델 복잡, 실제 상태와 논리적 상태 일치하지 않아 혼란.
            2. 10분마다 크론잡 도입
               ![스크린샷 2025-06-21 오후 5 54 19](https://github.com/user-attachments/assets/e29dbc52-c67f-4df6-8590-9f3104e616a9)
                - 예약됨 상태의 모든 티켓의 reserved_timestamp가 10분이상 경과한 티켓의 상태를 사용가능으로 변경함
                - 한계: 크론잡 실행 주기와 만료 시점 사이 지연 발생. 9분 지연 시 총 19분간 예약됨.
            3. 분산 락 - 최적 솔루션
               ![스크린샷 2025-06-21 오후 6 00 03](https://github.com/user-attachments/assets/0a76e956-444f-4677-ac9a-0b4ca4813785)

                - reserved_timestamp와 reserved 상태 다 제거하고 Redis와 같은 인메모리 캐시를 분산락으로 활용하기
                    - ticketId를 키로, TTL을 10분으로 저장하면 10분 후 알아서 삭제됨
                    - 이벤트 조회 시 디비에서 사용가능 티켓을 조회한 후 레디스 해당 티켓 ID가 있는지 확인하고 클라이언트에게 반환
                    - 사용자가 결제하지 않고 페이지를 닫아도 10분 후에 자동으로 락이 해제 되어 사용가능 상태가 됨.
                - 분산락을 사용하는 이유는 여러 예약 서비스 인스턴스가 동일한 락 상태를 공유해야하기 때문
                - 분산 락 서버 다운 시 시나리오:
                    1. 락 서버 다운 시 즉시 새 서버 배포
                    2. 다운되기 직전 10분동안 예약된 티켓들은 락이 해제되어 여러 사용자가 동시 구매를 시도 할 수 있음
                        1. 인메모리 캐시는 휘발성 메모리 - 서버 다운 시 데이터 모두 사라짐
                    3. 하지만 포스트그래의 ACID 속성 덕분에 최종적으로 한 명의 사용자만 성공하고 나머지는 오류를 받음
                    - 위 방법은 일관성은 유지 되지만 여러 사용자가 구매 실패 경험. 10분간의 혼란 으로 사용자 경험은 나빠짐
                        - 제품 팀과의 논의를 통해 허용 가능 여부 결정

<br/><br/>

### **5. Deep Dive 심층 분석**

- mid-level 지원자는 보통 위에서 멈춤
1. 저지연 검색 (느린 검색 속도) → 쿼리 최적화
    1. 검색 최적화된 데이터베이스를 사용하기: Elasticsearch
        <img width="1374" alt="스크린샷 2025-06-21 오후 6 06 18" src="https://github.com/user-attachments/assets/a8cb78ad-dd5f-4607-9409-33d607f3ac22" />
        - 역색인 inverted Index 사용
            - 문장을 용어화하여 매핑
        - 지리공간 쿼리 Geospatial Queries 지원: 위치, 날짜 등의 복합 검색도 효율적으로 처리
        - ElesticSearch는 내구성과 복잡한 트랜잭션 관리 미지원으로 주 디비로는 사용하지 않음
        - 주 디비와 엘라스틱서치의 일관성 유지 방법
            1. 애플리케이션 코드에서 양쪽에 동시 쓰기 작업 수행
                <img width="1115" alt="스크린샷 2025-06-21 오후 6 07 11" src="https://github.com/user-attachments/assets/f940a35a-9a0a-4ac4-8ca6-e93b9b91e1ac" />
                1. 구현은 단순하지만 한쪽 쓰기가 실패 시 롤백 또는 재시도 로직 필요
            2. CDC (Change Data Capture) 변경 데이터 캡쳐
                <img width="1193" alt="스크린샷 2025-06-21 오후 6 07 59" src="https://github.com/user-attachments/assets/33a58119-0b62-406c-a829-6a965f62ed7f" />
                1. 주 디비의 변경 사항을 스트림에 발행하고 엘라스틱이 이 스트림을 구독하면서 업데이트 함
                2. 데이터 일관성 유지에 효과적이고 코드의 복잡성을 줄일 수 있음
                3. 하지만 엘라스틱서치는 초당 쓰기 제한이 있기 때문에 업데이트가 잦은 시스템에서는 큐 또는 배치 처리가 필요할 수도 있음.
                    1. 이벤트 정보는 자주 바뀌지 않아서 본 시스템에는 직접 업데이트 방식도 적합
        - 면접관이 인기 검색어에 대한 캐싱 전략을 물어볼 수도 있음 (사용자별 추천이나 순위 검색을 안 한다면 누구나 같은 결과를 받기 때문에 캐싱하기 좋음)
            1. opensearch 노드 쿼리 캐싱
                1. 엘라스틱서치를 쓸 때 AWS의 opensearch를 사용하고 있을 가능성이 큼
                2. opensearch는 node query caching 기능이 있어서 같은 쿼리가 여러번 오면 결과를 미리 저장해서 빠르게 응답해줄 수 있음 : 그래서 내부적으로 지원해서 해결 가능
            2. 정적 메소드 CDN 
                ![스크린샷 2025-06-21 오후 6 10 55](https://github.com/user-attachments/assets/e372a2f4-d9c2-4c5d-9cf3-313b650dd28b)
                - 정적 이미지 용으로 사용되는 CDN을 검색 API응답 캐싱에 활용할 수 있음
                - 지리적으로 가까운 CDN에서 응답을 제공해 매우 빠름
                - 검색 쿼리의 복잡성이 높으면 캐시 적중률 낮아짐
                - 개인화된 검색 결과에는 적합하지 않음

2. 실시간 좌석 현황 업데이트
    1. 롱 폴링
        - 서버가 일정 시간 동안 응답을 보류하고, 좌석 변경이 발생하면 즉시 응답을 보냄.
        - 구현 간단. 사용자가 페이지에 머무는 시간이 짧을 때 효과적
    2. SSE server sent events
        - 클라이언트와 서버 사이 단방향 영구 연결을 설정하여 서버가 클라이언트에게 푸시할 수 있도록
        - 웹소켓이 완벽한 양반향 SSE는 단방향. 우리는 단방향만 필요함 서버가 잔여 좌석을 알려주기만 하면 됨

3. 가상 대기 큐: 인기 이벤트로 트래픽 급증에 대비한 확장성 전략
    <img width="1279" alt="스크린샷 2025-06-21 오후 6 16 52" src="https://github.com/user-attachments/assets/79b5eb8a-e114-4ee5-9008-0c5888d0ac03" />
    - 인기 이벤트는 수십만 명의 사용자가 동시에 접근해서 좌석이 순식간에 매진되면 사용자가 빈 좌석을 보지 못하고 오류 경험함
    - 백엔드 과부하 방지와 사용자 경험 개선을 위해 병목 지점 설정
        - 수많은 동시접근 사용자들이 이벤트 페이지 대신 대기열로 진입
        - 대기열은 레디스의 sorted set으로 도착 시간 기반 우선순위 큐로 만들 수 있음
        - 일정 좌석 예약될 때마다 대기열에서 다음 그룹의 사용자들을 순차적으로 입장시킴
        - SSE 연결 등으로 허용된 사용자에게 알림 보냄

4. 시스템 확장성 논의
  - API 게이트웨이 및 마이크로서비스 확장
      - 관리형 서비스로 자체 로드 밸런싱
  - 데이터베이스 샤딩: 대용량 데이터를 처리하기 위해 샤딩
      - 샤딩 키 선택 (eventId, venueId 고려)
  - 읽기 부하 감소를 위한 캐싱
      - 읽기 비율이 쓰기 비율보다 훨씬 높음. 읽기 부하 줄이는 것이 중요
      - 이벤트/장소/공연자 는 자주 변경되지 않으므로 레디스 캐싱에 적합

<br/><br/>

## 설계 검토 및 마무리
<img width="1646" alt="스크린샷 2025-06-21 오후 6 21 34" src="https://github.com/user-attachments/assets/2dedda82-4b07-4eab-883d-bdf9812d61c3" />
- 설계된 시스템이 모든 기능적/비기능적 요구사항을 충족하는지 최종적으로 검토하고 확인.
