# Week 5
# Study: Redis

## Redis 고가용성 구성 방식

### 1. Redis Sentinel (센티넬)
Redis Sentinel은 단일 마스터 구성을 전제
- **기능:** 장애 감지 및 자동 장애 조치 (Failover)
- **구성요소:**
    - **Master:** 실제 쓰기/읽기를 담당하는 Redis 서버
    - **Slave(s):** 마스터 복제본. 마스터 장애 시 승격 가능
    - **Sentinel:** 독립 프로세스. 마스터를 모니터링하고, 장애 발생 시 새로운 마스터를 자동 선출

- **특징:**
    - Sentinel은 클러스터가 아님
    - 클라이언트는 Sentinel을 통해 현재 마스터의 위치를 확인해야 함
    - 적절한 클라이언트 설정이 필수 (마스터 변경 감지 및 자동 연결)

- **장점:**
    - 구성 간단
    - Redis의 기능을 그대로 사용 가능
    - 소규모 서비스에 적합

### 2. Redis Cluster
Redis Cluster는 다중 마스터 (샤딩) 구조로 동작

- **기능:** 데이터 샤딩(분산 저장) + 고가용성
- **구성요소:**
    - 여러 개의 Master-Replica 쌍으로 구성 (보통 3~6개 노드)
    - 키를 해시 슬롯으로 나누어 각 노드에 분산 저장

- **특징:**
    - 각 노드는 일부 키 공간만 담당
    - 자동 장애 복구 및 노드 간 재조정 지원
    - 일부 키 접근 시 해당 노드만 필요하므로 확장성 우수

- **장점:**
    - 수평 확장 가능
    - 데이터 자동 분산
    - 고가용성과 확장성 동시에 확보

- **주의점:**
    - 다중 키 연산 제한 (e.g., MGET, MSET across slots 불가)
    - 클라이언트가 클러스터 모드를 지원해야 함

## Redis 복제(Replication)

### 1. 기본 구조:
- 마스터(Master): 데이터를 읽고/쓰기 가능한 본 서버
- 레플리카(Replica): 마스터가 가진 데이터를 그대로 따라 적는 서버

### 2. 복제 방식: 비동기(Asynchronous)
- 장점: 빠르고 효율적임
- 단점: 갑자기 서버가 꺼지면 레플리카와 데이터 불일치 가능성 있음
→ 최근 몇 초간 저장된 데이터가 손실될 수도 있음

### 3. 재동기화(Resynchronization)
1) Partial (부분 동기화)
   - 레플리카가 마지막 동기화 지점부터 읽기 요청 
   - 마스터가 거기서부터 보내줌 → 빠르게 복구 가능

2) Full (전체 동기화)
   - 레플리카가 전체 읽기 요청 
   - 마스터가 전체 스냅샷(RDB) 를 만들어 보내줌 
   - 레플리카는 스냅샷으로 받아쓰기 시작

### 4. 비차단 방식 (Non-blocking)
- Redis는 복제 중에도 마스터는 계속 요청 처리 가능 
- 레플리카는 기존 데이터로 읽기 처리 가능 
- 단, 전체 동기화 같은 경우에는 잠깐씩 느려질 수 있습니다.

### 5. 계층적 복제 (Cascade replication)
- 마스터 → 레플리카1 → 레플리카2 → 레플리카3 ...
   이런 계단식 구조로 복제 가능
- 마스터에게 연결이 몰리는 것을 방지할 수 있음
- 데이터도 정확히 동일하게 이어짐



## Redis Persistence

: 재시작 후에도 데이터를 보존하고 싶을 때는 디스크에 데이터를 저장하는 Persistence(지속성) 기능엔
두 가지 방식(또는 이들의 조합)을 지원

- RDB (Redis Database Snapshot)
- AOF (Append Only File)

### 1. RDB: Snapshot 기반 저장
개념: 
- 특정 시점의 Redis 메모리를 통째로 스냅샷(snapshot) 하여 .rdb 파일로 dump.

장점:
- 복구가 빠르다.
- 전체 메모리 덤프이기 때문에, 부팅 시 바로 적재 가능.
- 저장 파일 크기가 작음.(LZW 압축)

단점:
- 마지막 스냅샷 이후의 변경 사항은 유실 가능.
- 복구중 중단되면 데이터 손실.

사용 예:
- 백업 목적 
- 빠른 재시작이 중요한 경우

### 2. AOF: Write Log 기반 저장
개념: 
- Redis의 모든 쓰기 명령어들을 순차적으로 기록하여 .aof 파일에 저장.
- Redis 재시작 시 이 로그를 replay하여 메모리 상태를 복구.

장점:
- RDB보다 데이터 손실 위험이 훨씬 적음 (1초 미만까지 줄일 수 있음).
- 로그이기 때문에 트러블슈팅이나 데이터 재생에 유리함.

단점:
- 파일이 계속 커짐 (rewrite로 줄일 수 있음)
- 복구 속도가 느릴 수 있음 (명령 재실행 필요)

AOF Rewrite (로그 축소)

: AOF는 시간이 지나면서 파일이 커지므로, Redis는 자동으로 AOF를 "rewrite"하여 줄입니다.

방식:
- Redis는 현재 상태를 기반으로 최소한의 명령어 집합으로 재기록.
- 서비스는 중단되지 않으며, rewrite 중에도 명령이 계속 기록됨.


### 3. RDB + AOF 조합 사용
Redis는 둘을 함께 사용할 수 있다.

이 조합의 목적:
- RDB: 빠른 부팅용 (덤프)
- AOF: 최신 데이터 보존용 (log replay)

동작 흐름 (복구 순서):
- Redis는 AOF가 존재하면 AOF 우선 사용하여 복구.
- AOF가 없거나 손상되었을 경우, RDB로 복구 시도.

### 6. 권장 사항
- 운영 환경에서는 RDB + AOF 조합 사용을 권장.
- 주기적인 RDB 스냅샷은 백업용도로도 매우 유용.
- AOF 파일은 별도로 주기적 백업(S3 등)에 저장할 것을 권장.
