# Ad Aggregator System Design Review

## 개요
이번 스터디에서는 광고 집계 시스템 설계에 대해 분석했습니다. 먼저 요구사항을 파악하고 아키텍처를 설계한 후, [시스템 디자인 강의](https://www.youtube.com/watch?v=Zcv_899yqhI)의 아키텍처와 비교 분석을 진행했습니다.

## 주요 차이점 분석

### 1. 사용자 유형 분류
#### 내 설계
- 단일 사용자 유형으로만 고려

#### 강의 아키텍처
- 사용자를 목적에 따라 분리
  - 광고 클릭 사용자: 실제 광고와 상호작용하는 최종 사용자
  - 데이터 조회 사용자: 광고 성과를 분석하는 광고주/관리자

### 2. 서비스 책임 분리
#### 내 설계
- `Metric Service`가 모든 지표 관련 책임을 단일 서비스로 처리

#### 강의 아키텍처
- 책임에 따른 명확한 서비스 분리
  - **클릭 프로세서**
    - 광고 클릭 이벤트 수신
    - 클릭 데이터 검증
    - 광고주 웹사이트로 리디렉션 (302 HTTP 응답)
  - **쿼리 서비스**
    - 광고주의 클릭 지표 조회 처리
    - 읽기/쓰기 요청 분리를 통한 확장성 확보

### 3. 데이터베이스 아키텍처
#### 내 설계
- 단순 RDB 사용 계획

#### 강의 아키텍처
- **이원화된 데이터베이스 전략**
  - **Cassandra** (쓰기 최적화)
    - 초당 10,000 클릭의 쓰기 부하 처리
    - 멤테이블을 통한 고성능 쓰기 지원
  - **OLAP 데이터베이스** (읽기 최적화)
    - 저지연 분석 쿼리 처리 (1초 미만)
    - Spark/Flink를 통한 사전 집계 데이터 저장

### 4. 실시간 데이터 처리 파이프라인
#### 내 설계
- Kafka → RDS 단순 구조

#### 강의 아키텍처
- **고도화된 실시간 처리 파이프라인**
  1. Kinesis Stream: 클릭 데이터 초기 수집
  2. Flink: 실시간 데이터 처리
     - 1분 단위 집계 윈도우
     - 10초 간격 OLAP DB 기록
  3. 근실시간(Near Real-time) 데이터 제공

- **Spark에서 Flink로의 전환 이유**
  1. **Spark의 한계**
     - 배치 처리 기반: 5분 주기의 MapReduce 배치 작업
     - 높은 지연 시간: 광고 성과 확인에 최대 5분 소요
     - 잦은 실행 시 비효율: 짧은 주기 실행 시 높은 오버헤드
  2. **Flink의 장점**
     - 스트림 기반 실시간 처리: 이벤트 발생 즉시 처리
     - 인메모리 집계: 1분 윈도우 내 지속적 데이터 집계
     - 부분 결과 제공: 10초 간격으로 중간 집계 결과 제공
     - 결과적으로 실시간성과 낮은 지연 시간 요구사항 충족

### 5. 장애 복구 메커니즘
#### 내 설계
- 장애 복구 고려사항 누락

#### 강의 아키텍처
- **다층적 복구 전략**
  1. **스트림 유지 정책**
     - Kinesis Stream 7일 데이터 보존
     - 프로세서 장애 시 재처리 가능
  2. **주기적 데이터 조정**
     - Spark MapReduce 배치 처리
     - 스트림 처리 결과 검증 및 보정
  3. **Lambda/Kappa 아키텍처 혼합**
     - 실시간 처리의 신속성
     - 배치 처리의 정확성 보장

### 6. 중복 클릭 방지 및 스팸 처리
#### 내 설계
- 중복/스팸 처리 메커니즘 누락

#### 강의 아키텍처
- **멱등성 보장 시스템**
  1. **광고 노출 ID 시스템**
     - 각 광고 노출마다 고유 Impression ID 발급
     - 서명된 ID로 조작 방지
  2. **Redis 기반 중복 처리**
     - 처리된 Impression ID 캐싱
     - 중복 클릭 필터링

### 7. 확장성 및 Hot Shard 문제 해결
#### 내 설계
- Gateway와 Kafka를 통한 기본적 확장성 고려

#### 강의 아키텍처
- **다차원 확장 전략**
  1. **수평적 확장**
     - 프런트엔드 서비스 확장
     - 로드 밸런서/API 게이트웨이 활용
  2. **스트림 샤딩**
     - 광고 ID 기반 샤딩
     - 난수(0~N) 추가로 Hot Shard 문제 해결
  3. **OLAP 데이터베이스 최적화**
     - 광고주 ID 기반 샤딩
     - 쿼리 성능 최적화



## 몰랐던 개념 정리

### HTTP 리디렉션 (301 vs 302)
- **301 (Permanent Redirect)**
  - 영구적인 URL 이동을 의미
  - 브라우저가 이동된 URL을 캐시
  - SEO에 영향을 미침 (검색엔진이 새 URL을 인덱싱)
- **302 (Temporary Redirect)**
  - 임시 URL 이동을 의미
  - 광고 클릭 추적에 적합 (매번 클릭 서버를 거쳐 기록 가능)
  - 원래 URL의 SEO 영향 없음

### 데이터 처리 도구
#### Amazon Kinesis
- 실시간 데이터 스트리밍 플랫폼
- 대규모 데이터 스트림을 실시간으로 수집, 처리, 분석
- 주요 특징
  - 자동 확장/축소
  - 데이터 보존 기간 설정 가능
  - 여러 소비자가 동시에 같은 스트림 처리 가능

#### Apache Spark
- 대규모 데이터 처리를 위한 통합 분석 엔진
- 주요 특징
  - 배치 처리에 최적화
  - 인메모리 처리로 높은 성능
  - SQL, 머신러닝, 그래프 처리 등 다양한 워크로드 지원
- 한계
  - 실시간 처리에는 상대적으로 부적합
  - 잦은 배치 작업 시 오버헤드 발생

#### Apache Flink
- 스트림 및 배치 처리를 위한 분산 처리 엔진
- 주요 특징
  - 진정한 스트리밍 처리 (이벤트 발생 즉시)
  - 상태 관리 기능 내장
  - 정확히 한 번(exactly-once) 처리 보장
  - 백프레셔(backpressure) 처리 지원

### OLAP (Online Analytical Processing)
- 데이터 분석에 최적화된 처리 방식
- 주요 특징
  - 복잡한 분석 쿼리에 최적화
  - 대량의 이력 데이터 처리
  - 다차원 분석 지원
- 사용 사례
  - 트렌드 분석
  - 성과 보고서 생성
  - 데이터 마이닝
- 대표적인 OLAP 데이터베이스
  - **Amazon Redshift**
    - AWS의 데이터 웨어하우스
    - 페타바이트 규모의 데이터 처리
    - 컬럼 기반 저장으로 빠른 집계 쿼리
  - **Snowflake**
    - 클라우드 기반 데이터 웨어하우스
    - 자동 확장/축소 기능
    - 다중 클라우드 지원
  - **Apache Druid**
    - 실시간 분석에 특화
    - 밀리초 단위의 쿼리 응답
    - 스트리밍 데이터 실시간 집계
  - **ClickHouse**
    - 오픈소스 컬럼 기반 DBMS
    - 초당 수십억 행 처리 가능
    - 실시간 쿼리에 강점

### 데이터 처리 아키텍처
#### Lambda 아키텍처
- 배치층과 스피드층을 결합한 하이브리드 접근방식
- 구성
  - 배치층: 정확성 보장 (Spark)
  - 스피드층: 실시간성 보장 (Flink)
  - 서빙층: 두 결과를 결합하여 제공
- 장점: 정확성과 실시간성 모두 확보
- 단점: 두 개의 처리 파이프라인 유지 필요

#### Kappa 아키텍처
- 단일 스트림 처리 파이프라인으로 구성
- 모든 데이터를 스트림으로 처리
- 장점
  - 단순한 아키텍처
  - 유지보수 용이
- 단점
  - 재처리 시 전체 스트림 재생 필요
  - 배치 처리 대비 비용 증가 가능

#### CQRS (Command Query Responsibility Segregation) 패턴
- 명령(쓰기)과 조회(읽기) 책임을 분리하는 아키텍처 패턴
- 주요 특징
  - 쓰기/읽기 모델 분리
  - 각 모델에 최적화된 데이터 저장소 사용
  - 독립적인 확장 가능
- 장점
  - 각 작업에 최적화된 성능
  - 독립적인 스케일링
  - 높은 가용성
- 단점
  - 복잡한 구현
  - 데이터 일관성 관리 필요
  - 인프라 비용 증가
- 광고 시스템 적용
  - 쓰기: Cassandra (클릭 데이터 저장)
  - 읽기: OLAP DB (분석 쿼리 처리)

#### Cassandra의 쓰기 최적화 특징
- **멤테이블(Memtable) 구조**
  - 메모리 상주 데이터 구조
  - 쓰기 작업을 메모리에 먼저 기록
  - 주기적으로 디스크에 플러시(SSTable 생성)
  - SSTable에는 키가 정렬된 상태로 저장이 되어있고, 키-값 쌍들이 순서대로 기록되어 키 기반의 빠른 탐색이 가능하다. 
- **로그 구조 병합 트리(Log-Structured Merge Tree)**
  - 순차적 디스크 쓰기로 성능 향상
  - 백그라운드 컴팩션으로 데이터 최적화
- **분산 아키텍처**
  - 쓰기 작업의 분산 처리
  - 노드 간 데이터 자동 복제
  - 장애 시에도 쓰기 작업 보장
- **튜닝 가능한 일관성**
  - 쓰기 성능과 일관성 사이의 균형 조절
  - 상황에 맞는 일관성 레벨 선택 가능

이러한 특징들로 인해 Cassandra는:
- 초당 수만 건의 쓰기 처리 가능
- 선형적인 확장성 제공
- 쓰기 지연 시간 최소화
- 고가용성 보장

